// need to handle stereo wavs!!! and 32 bit wavs

// need to reset pointers on loading new wav

// draw playback indicators for each pointer? (brightness as volume too)

// need to scale volume down per voice
// convert to 32 bit for more headroom? then normalize before outputing?


//possible controls/options/etc:
// swarm density (# of pointers)
// loop length (per pointer)
// loop change probability, loop change range
// direction (forward or reverse)
// main loop start point
// loop start range
// options for crossfading each loop????
// attack/release time (for when adding or removing 'voices')

// multiple xy pads (color coded, faded color when not controlled)
// select which to use w/ buttons



set_pixel_size(1)

resize( get_screen(), WINDOW_XSIZE, WINDOW_YSIZE )



include "constants.pixi"
include "util.pixi"

include "wave_window.pixi"
include "swarm.pixi"
include "audiocallback.pixi"

include "button.pixi"
include "buttons.pixi"




load_wav()

swarm = create_swarm()
swarm.init_pointers(swarm)


buttons = create_buttons()


touch_state = new()
touch_state.down = 0
touch_state.up = 0
touch_state.move = 0






while (1)
{
    while get_event()
    {
        touch_state.down = 0
        touch_state.up = 0
        touch_state.move = 0 
               
        if EVT[EVT_TYPE] == EVT_QUIT { cleanup() }
        
        if EVT[EVT_TYPE] == EVT_MOUSEBUTTONUP
            { touch_state.up = 1 }
        
  		if EVT[EVT_TYPE] == EVT_MOUSEMOVE 
            { touch_state.move = 1 }
        
  		if EVT[EVT_TYPE] == EVT_MOUSEBUTTONDOWN 
            { touch_state.down = 1 }
  		
  	  		
  	    touch_state.x = EVT[ EVT_X ]
  		touch_state.y = EVT[ EVT_Y ]
  		
  		
  		wave_window.update(wave_window, touch_state)
  		buttons.update(buttons, touch_state)
  	}
  	
  	
  	
  	clear(get_blend(BLACK, WHITE, 130))
  	
  	
  	wave_window.draw(wave_window)
  	buttons.draw(buttons)
  	
  	printnum(s, 0, 0)
  	
  	frame()
  	
  	
}



fn cleanup()
{

    set_audio_callback(-1)
    
    
    
    halt
}



fn load_wav()
{

    set_audio_callback(-1)
    $file = file_dialog( "Select a wav file", "wav", "fff" )
    if $file > -1
    {
        if wave_window
        {
            remove(wave_window)
        }
        $wav_data = load($file)
        
        wave_window = create_wave_window(
                                        $wav_data, 
                                        XMIN + BORDER, 
                                        YMIN + BORDER, 
                                        WAVE_WIDTH, 
                                        WAVE_HEIGHT
                                        )

    }
    $wav_data = wave_window.data
    set_audio_callback(audio_callback, 0, 44100, get_type( $wav_data ), 1 ,AUDIO_FLAG_INTERP2 )

}


  		
